import { IInjectablesCollection, IInjection, IModulesCollection, IPluginDefinitionsCollection } from './interface.js';
import generateProxyFileCode from './generate-proxy-file-code.js';
import fs from 'node:fs';
import path from 'node:path';
import getInjectables from './get-injectables.js';
import getInjections from './get-injections.js';
import parseExportable from './parse-exportable.js';
import getPlugins from './get-plugins.js';

const writeProxyFile = async (
    modules: IModulesCollection,
    proxyFilePath: string,
    subject: string,
    sourceCode: string,
    injection: IInjection,
    injectables: IInjectablesCollection,
    plugins: IPluginDefinitionsCollection
) => {
    // console.log(`Baking: ${subject}`);

    const generatedIntro = '// This file is generated by Seada.io. Do not edit manually!\n' + '// @ts-nocheck\n' + '\n';

    try {
        const proxySourceCode =
            generatedIntro +
            (await generateProxyFileCode(modules, subject, sourceCode, injection, injectables, plugins));
        fs.writeFileSync(proxyFilePath, proxySourceCode);
    } catch (error) {
        console.error(`Error generating proxy file for ${subject}`, error);
    }
};

/**
 * Find file extension from a list of allowed extensions
 * @param filePathWithoutExtension
 * @param allowedExtensions
 */
const findFileExtension = (filePathWithoutExtension: string, allowedExtensions: string[]) => {
    for (const extension of allowedExtensions) {
        const filePathWithExtension = filePathWithoutExtension + extension;
        if (fs.existsSync(filePathWithExtension)) {
            return extension;
        }
    }

    return null;
};

/**
 * Generate proxy files for injections
 * @param modules
 */
const generateProxyFiles = async (modules: IModulesCollection): Promise<string[]> => {
    const injectables = getInjectables(modules);
    const injections = getInjections(modules);
    const plugins = getPlugins(modules);

    // Subjects to generate proxy files for (plugins + injections)
    const proxyFilesTasks = [];
    const subjects = Object.keys({ ...plugins, ...injections });

    const generatedFiles = [];

    for (const subject of subjects) {
        const [moduleName, filePath] = parseExportable(modules, subject);
        const { sourcePath, generatedPath } = modules[moduleName];

        const allowedExtensions = ['.ts', '.tsx'];
        const filePathWithoutExtension = path.join(sourcePath, filePath);
        const fileExtension = findFileExtension(filePathWithoutExtension, allowedExtensions);

        const sourceFilePath = path.join(sourcePath, filePath) + fileExtension;
        const proxyFilePath = path.join(generatedPath, filePath) + fileExtension;

        const sourceCode = fs.readFileSync(sourceFilePath, 'utf-8');
        const injectionForSubject = injections[subject];
        const pluginsForSubject = plugins[subject] || {};

        const generatedDir = path.dirname(proxyFilePath);
        if (!fs.existsSync(generatedDir)) {
            fs.mkdirSync(generatedDir, { recursive: true });
        }

        generatedFiles.push(proxyFilePath);

        proxyFilesTasks.push(
            writeProxyFile(
                modules,
                proxyFilePath,
                subject,
                sourceCode,
                injectionForSubject,
                injectables,
                pluginsForSubject
            )
        );
    }

    await Promise.all(proxyFilesTasks);
    return generatedFiles;
};

export default generateProxyFiles;
